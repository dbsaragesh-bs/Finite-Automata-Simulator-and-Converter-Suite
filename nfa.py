from __future__ import annotations
from collections import deque
from typing import Literal, Set, Dict, List, Optional, Tuple
from graphviz import Digraph
import time

try:
    import streamlit as st
except ImportError:
    st = None

# Import local modules (adjust if you have a package structure)
from finite_automata import FA
from dfa import DFA
from utils import list_filter, list_map, flatten_list

import re

def _simplify_regex(expr: str) -> str:
    """Simplify a regex string generated by state elimination."""
    if not expr:
        return "∅"

    prev = None
    while prev != expr:
        prev = expr
        # Remove redundant outer parentheses
        expr = re.sub(r"\(([^()]+)\)", r"\1", expr)
        # Collapse duplicates: a|a -> a
        expr = re.sub(r"(\w)\|\1", r"\1", expr)
        # Simplify epsilon concatenations
        expr = expr.replace("ε", "")
        # Collapse nested stars: (a*)* -> a*
        expr = re.sub(r"\((\w\*)\)\*", r"\1", expr)
        # Collapse duplicates with words: ab|ab -> ab
        expr = re.sub(r"(\w+)\|\1", r"\1", expr)

    return expr



class NFA(FA):
    """A Class used to represent a Non-Deterministic Finite Automaton"""

    def __init__(
        self,
        q: Set[str],
        sigma: Set[str],
        delta: Dict[str, Dict[str, Set[str]]],
        initial_state: str,
        f: Set[str],
    ) -> None:
        super().__init__(q, sigma, delta, initial_state, f)

    def is_valid(self) -> bool:
        """Returns True if the NFA is a valid automaton"""
        return (
            self._validate_initial_state()
            and self._validate_final_states()
            and self._validate_transitions()
        )

    def complement(self) -> "NFA":
        dfa = self.get_dfa()
        dfa = dfa.complement()
        nfa = dfa.get_nfa()
        nfa.renumber()
        return nfa.minimize()

    def contains_epsilon_transitions(self) -> bool:
        for q in self.delta:
            if "" in self.delta[q]:
                return True
        return False

    def remove_epsilon_transitions(self) -> "NFA":
        q_prime = self.q.copy()
        delta_prime = self.delta.copy()
        delta_init_state = self.initial_state
        delta_f = self.f.copy()

        if not self.contains_epsilon_transitions():
            return NFA(q_prime, self.sigma, delta_prime, delta_init_state, delta_f)

        delta_prime = dict()
        for q in q_prime:
            closure_states = self.__get_e_closure(q)
            for sigma in self.sigma:
                new_transitions = self.__ret_get_new_transitions(
                    q, sigma, closure_states, delta_f
                )
                self.__ret_update_delta(delta_prime, q, sigma, new_transitions)

        return NFA(q_prime, self.sigma, delta_prime, delta_init_state, delta_f)

    def __get_e_closure(
        self, q: str, visited: Optional[List[str]] = None
    ) -> List[str]:
        ans = [q]
        if visited is None:
            visited = [q]

        if q in self.delta and "" in self.delta[q]:
            for st in self.delta[q][""]:
                if st not in visited:
                    visited.append(st)
                    ans.extend(
                        [k for k in self.__get_e_closure(st, visited) if k not in ans]
                    )
        return ans

    def __ret_get_new_transitions(
        self, q: str, sigma: str, closure_states: List[str], delta_f: Set[str]
    ):
        to_epsilon_closure: List[str] = []
        new_transitions: List[str] = []

        for closure_state in closure_states:
            if closure_state in self.f:
                delta_f.add(q)
            if closure_state in self.delta and sigma in self.delta[closure_state]:
                to_epsilon_closure.extend(self.delta[closure_state][sigma])

        for epsilon_closure in to_epsilon_closure:
            new_transitions.extend(self.__get_e_closure(epsilon_closure))

        return new_transitions

    def __ret_update_delta(
        self,
        delta_prime: Dict[str, Dict[str, Set[str]]],
        q: str,
        sigma: str,
        new_transitions: List[str],
    ):
        if q not in delta_prime:
            delta_prime[q] = dict()
        if sigma != "":
            delta_prime[q][sigma] = set(new_transitions)

    def get_dfa(self) -> DFA:
        local_nfa = NFA(self.q, self.sigma, self.delta, self.initial_state, self.f)
        local_nfa = local_nfa.remove_epsilon_transitions()

        q_prime = []
        delta_prime: Dict[str, Dict[str, str]] = dict()
        
        # Mapping from state sets to new simple names
        state_mapping: Dict[str, str] = {}
        state_counter = 0

        queue = deque()
        visited = [[local_nfa.initial_state]]
        queue.append([local_nfa.initial_state])

        while queue:
            qs = queue.pop()
            local_transitions: Dict[str, str] | Dict[str, List[str]] = dict()

            states_in_nfa_delta = filter(lambda q: q in local_nfa.delta, qs)

            for q in states_in_nfa_delta:
                for s in local_nfa.delta[q]:
                    tmp = local_nfa.delta[q][s].copy()
                    self.__extend_local_transitions(tmp, s, local_transitions)

            self.__update_local_transitions(local_transitions, visited, queue, state_mapping, state_counter)

            # Create simple state name
            state_key = ",".join(sorted(qs))
            if state_key not in state_mapping:
                state_mapping[state_key] = f"q{state_counter}"
                state_counter += 1
            
            state_name = state_mapping[state_key]
            
            # Map transition targets to new names
            mapped_transitions = {}
            for symbol, target in local_transitions.items():
                if isinstance(target, str):
                    mapped_transitions[symbol] = target
                else:
                    target_key = ",".join(sorted(target))
                    if target_key not in state_mapping:
                        state_mapping[target_key] = f"q{state_counter}"
                        state_counter += 1
                    mapped_transitions[symbol] = state_mapping[target_key]
            
            delta_prime[state_name] = mapped_transitions
            q_prime.append(qs)

        f_prime = set()
        aux = set()

        for qs in q_prime:
            state_key = ",".join(sorted(qs))
            state_name = state_mapping[state_key]
            aux.add(state_name)
            for q in qs:
                if q in local_nfa.f:
                    f_prime.add(state_name)
                    break

        q_prime = aux

        initial_state_key = local_nfa.initial_state
        initial_state = state_mapping[initial_state_key]

        return DFA(
            q_prime,
            local_nfa.sigma,
            delta_prime,
            initial_state,
            f_prime,
        )

    def __extend_local_transitions(
        self, tmp: Set[str], s: str, local_transitions: Dict[str, List[str]]
    ) -> None:
        if tmp and s in local_transitions:
            local_transitions[s].extend([k for k in tmp if k not in local_transitions[s]])
        elif tmp:
            local_transitions[s] = list(tmp)

    def __update_local_transitions(
        self,
        local_transitions: Dict[str, List[str]],
        visited: List[List[str]],
        queue: deque,
        state_mapping: Dict[str, str] = None,
        state_counter: int = 0,
    ) -> None:
        for transition in local_transitions:
            local_transitions[transition] = sorted(local_transitions[transition])
            tmp = local_transitions[transition].copy()
            if tmp not in visited:
                queue.append(tmp)
                visited.append(tmp)
            # Keep as list for now, will be mapped in get_dfa
            local_transitions[transition] = tmp

    def minimize(self) -> "NFA":
        local_dfa = self.get_dfa().minimize()
        local_nfa = local_dfa.get_nfa()
        local_nfa.renumber()
        return local_nfa

    def renumber(self, prefix="q") -> None:
        new_tags = {state: f"{prefix}{idx}" for idx, state in enumerate(self.q)}
        q = {new_tags[state] for state in self.q}
        f = {new_tags[state] for state in self.f}
        initial_state = new_tags[self.initial_state]

        delta = {}
        for _q in self.delta:
            delta[new_tags[_q]] = {
                s: {new_tags[nxt_state] for nxt_state in self.delta[_q][s]}
                for s in self.delta[_q]
            }

        self.q, self.f, self.delta, self.initial_state = q, f, delta, initial_state

    def union(self, m: "NFA") -> "NFA":
        sigma = self.sigma.union(m.sigma)
        q = {"q0"}
        f = set()
        initial_state = "q0"
        real_value_self = {}
        real_value_m = {}

        for i, _q in enumerate(self.q, 1):
            real_value_self[_q] = f"q{i}"
            q.add(real_value_self[_q])

        for i, s in enumerate(m.q):
            real_value_m[s] = f"s{i}"
            q.add(real_value_m[s])

        for _q in self.f:
            f.add(real_value_self[_q])

        for _q in m.f:
            f.add(real_value_m[_q])

        self_delta = self.__get_new_delta_real_value(self.delta, real_value_self)
        m_delta = self.__get_new_delta_real_value(m.delta, real_value_m)

        delta = {
            **self_delta,
            **m_delta,
            initial_state: {
                "": {
                    real_value_self[self.initial_state],
                    real_value_m[m.initial_state],
                }
            },
        }

        return NFA(q, sigma, delta, initial_state, f)

    def __get_new_delta_real_value(
        self, delta: Dict[str, Dict[str, Set[str]]], real_value: Dict[str, str]
    ) -> Dict[str, Dict[str, Set[str]]]:
        new_delta = {}
        for q, transition in delta.items():
            tmp_dict = {}
            for s, states in transition.items():
                tmp_dict[s] = {real_value[state] for state in states}
            new_delta[real_value[q]] = tmp_dict.copy()
        return new_delta

    def intersection(self, m: "NFA") -> "NFA":
        if self.sigma != m.sigma:
            return NFA(set(), set(), {}, "", set())

        new_q_list: List[Tuple[str, str]] = []
        initial_state = str((self.initial_state, m.initial_state))
        delta: Dict[str, Dict[str, Set[str]]] = {}
        f: Set[str] = set()
        sigma = self.sigma.copy()

        queue = deque()
        queue.append((self.initial_state, m.initial_state))

        while queue:
            a, b = queue.popleft()
            new_q_list.append((a, b))

            if a in self.f and b in m.f:
                f.add(str((a, b)))

            common_transitions = self.delta[a].keys() & m.delta[b].keys()

            for s in common_transitions:
                a_next_states = self.delta[a][s].copy()
                b_next_states = m.delta[b][s].copy()
                next_states = {(x, y) for x in a_next_states for y in b_next_states}

                unexplored_states = {x for x in next_states if x not in new_q_list}
                new_q_list.extend(unexplored_states)
                for x in unexplored_states:
                    queue.append(x)

                if str((a, b)) not in delta:
                    delta[str((a, b))] = {}
                delta[str((a, b))][s] = {str(x) for x in next_states}

        return NFA(set(map(str, new_q_list)), sigma, delta, initial_state, f)

    def product(self, m: "NFA") -> "NFA":
        a = self.get_dfa()
        b = m.get_dfa()
        return a.product(b).get_nfa()

    def view(
        self,
        file_name: str,
        file_format: Literal["svg", "png"] = "png",
        node_attr: Optional[Dict[str, str]] = None,
        edge_attr: Optional[Dict[str, str]] = None,
    ) -> None:
        dot = self._create_base_graph(file_name, file_format, node_attr, edge_attr)
        for q in self.delta:
            for s in self.delta[q]:
                for t in self.delta[q][s]:
                    dot.edge(q, t, label="ε" if s == "" else s)
        dot.render()

# ========================================================
# Helper functions for dict-based NFAs (with animation)
# ========================================================

def generate_nfa_visualization(nfa):
    dot = Digraph(engine="dot", graph_attr={'rankdir': 'LR'})
    for state in nfa["states"]:
        if state in nfa["end_states"]:
            dot.node(str(state), shape="doublecircle")
        else:
            dot.node(str(state), shape="circle")
    for (source_state, symbol), targets in nfa["transitions"].items():
        for t in (targets if isinstance(targets, (set, list, tuple)) else [targets]):
            dot.edge(str(source_state), str(t), label=str(symbol))
    return dot

def _epsilon_symbols():
    return {"ε", ""}

def _epsilon_closure(nfa, states):
    eps_syms = _epsilon_symbols()
    stack = list(states)
    closure = set(states)
    while stack:
        s = stack.pop()
        for eps in eps_syms:
            targets = nfa["transitions"].get((s, eps), set())
            for t in (targets if isinstance(targets, (set, list, tuple)) else [targets]):
                if t not in closure:
                    closure.add(t)
                    stack.append(t)
    return closure

def validate_nfa(nfa, string):
    start = nfa.get("start_state", None)
    if start is None:
        starts = set(nfa.get("start_states", []))
    else:
        starts = {start}

    current = _epsilon_closure(nfa, starts)
    state_checks = []

    for char in string:
        next_states = set()
        for s in current:
            sym = char
            if (s, "0,1") in nfa["transitions"]:
                sym = "0,1"
            if (s, "a,b") in nfa["transitions"]:
                sym = "a,b"

            targets = nfa["transitions"].get((s, sym), set())
            for t in (targets if isinstance(targets, (set, list, tuple)) else [targets]):
                next_states.add(t)

        if not next_states:
            state_checks.append((frozenset(current), False))
            return (False, state_checks)

        current = _epsilon_closure(nfa, next_states)
        state_checks.append((frozenset(current), True))

    final_ok = any(s in nfa["end_states"] for s in current)
    state_checks.append((frozenset(current), final_ok))
    return (final_ok, state_checks)

def animate_nfa_validation(nfa, state_checks, delay=1.0, blink=0.5):
    if st is None:
        raise RuntimeError("Streamlit is required for animation. pip install streamlit")

    dot = generate_nfa_visualization(nfa)
    placeholder = st.empty()
    placeholder.graphviz_chart(dot.source, use_container_width=True)

    end_states = set(nfa["end_states"])

    for states, is_valid in state_checks:
        time.sleep(delay)
        for s in states:
            dot.node(str(s), style="filled", fillcolor="yellow")
        placeholder.graphviz_chart(dot.source, use_container_width=True)

        if not is_valid:
            time.sleep(blink)
            for s in states:
                dot.node(str(s), style="filled", fillcolor="red")
            placeholder.graphviz_chart(dot.source, use_container_width=True)
        else:
            time.sleep(blink)
            for s in states:
                dot.node(str(s), style="filled", fillcolor="white")
            placeholder.graphviz_chart(dot.source, use_container_width=True)

    if state_checks:
        final_states, final_ok = state_checks[-1]
        if final_ok:
            for s in final_states:
                color = "green" if s in end_states else "white"
                dot.node(str(s), style="filled", fillcolor=color)
        else:
            for s in final_states:
                dot.node(str(s), style="filled", fillcolor="red")
        placeholder.graphviz_chart(dot.source, use_container_width=True)

# This is the "correct" accept you wanted to keep
def accept(nfa, string, animate=False):
    ok, checks = validate_nfa(nfa, string)
    if animate:
        animate_nfa_validation(nfa, checks)
    return ok
