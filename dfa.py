from utils import list_map
from finite_automata import FA
from collections import deque
from typing import (
    Callable,
    Literal,
    Set,
    Dict,
    List,
    Tuple,
    Optional,
    FrozenSet,
)
import itertools
from graphviz import Digraph
import time

try:
    import streamlit as st
except ImportError:
    st = None

import re

def _simplify_regex(expr: str) -> str:
    """Simplify a regex string generated by state elimination."""
    if not expr:
        return "∅"

    prev = None
    while prev != expr:
        prev = expr
        # Remove redundant outer parentheses
        expr = re.sub(r"\(([^()]+)\)", r"\1", expr)
        # Collapse duplicates: a|a -> a
        expr = re.sub(r"(\w)\|\1", r"\1", expr)
        # Simplify epsilon concatenations
        expr = expr.replace("ε", "")
        # Collapse nested stars: (a*)* -> a*
        expr = re.sub(r"\((\w\*)\)\*", r"\1", expr)
        # Collapse duplicates with words: ab|ab -> ab
        expr = re.sub(r"(\w+)\|\1", r"\1", expr)

    return expr


class DFA(FA):
    """Deterministic Finite Automaton (DFA) implementation."""

    def __init__(
        self,
        q: Set[str],
        sigma: Set[str],
        delta: Dict[str, Dict[str, str]],
        initial_state: str,
        f: Set[str],
    ) -> None:
        super().__init__(q, sigma, delta, initial_state, f)

    def is_valid(self) -> bool:
        """Returns True if the DFA is a valid automaton."""
        return (
            self._validate_initial_state()
            and self._validate_final_states()
            and self._validate_transitions()
        )

    def complement(self) -> "DFA":
        """Returns the complement of the DFA."""
        q = self.q
        sigma = self.sigma
        delta = self.delta
        initial_state = self.initial_state
        f = {state for state in self.q if state not in self.f}
        return DFA(q, sigma, delta, initial_state, f)

    def __binary_operation(
        self,
        m: "DFA",
        operation: Callable[[str, Set[str], str, Set[str]], bool],
    ) -> "DFA":
        """Helper for union, intersection, difference, symmetric difference."""
        new_q_list: List[Tuple[str, str]] = []
        initial_state = str((self.initial_state, m.initial_state))
        delta: Dict[str, Dict[str, str]] = dict()
        sigma: Set[str] = self.sigma.copy()
        f: Set[str] = set()

        if self.sigma != m.sigma:
            raise ValueError(
                f"{self.sigma}, Sigma from both DFAs must be the same"
            )

        queue: deque[Tuple[str, str]] = deque()
        queue.append((self.initial_state, m.initial_state))

        while queue:
            a, b = queue.popleft()
            new_q_list.append((a, b))

            if operation(a, self.f, b, m.f):
                f.add(str((a, b)))

            common_transitions = self.delta[a].keys() & m.delta[b].keys()

            for s in common_transitions:
                new_q = (self.delta[a][s], m.delta[b][s])
                if new_q not in new_q_list:
                    queue.append(new_q)
                    new_q_list.append(new_q)

                if str((a, b)) in delta:
                    delta[str((a, b))][s] = str(new_q)
                else:
                    delta[str((a, b))] = {s: str(new_q)}

        return DFA(set(map(str, new_q_list)), sigma, delta, initial_state, f)

    def union(self, m: "DFA") -> "DFA":
        return self.__binary_operation(m, lambda a, f, b, f_m: a in f or b in f_m)

    def intersection(self, m: "DFA") -> "DFA":
        return self.__binary_operation(m, lambda a, f, b, f_m: a in f and b in f_m)

    def difference(self, m: "DFA") -> "DFA":
        return self.__binary_operation(m, lambda a, f, b, f_m: a in f and b not in f_m)

    def symmetric_difference(self, m: "DFA") -> "DFA":
        return self.__binary_operation(
            m, lambda a, f, b, f_m: (a in f) ^ (b in f_m)
        )

    def product(self, m: "DFA") -> "DFA":
        initial_state = str((self.initial_state, m.initial_state))
        cross_product_states = {(q1, q2) for q1, q2 in itertools.product(self.q, m.q)}
        q = {str(state) for state in cross_product_states}
        sigma = self.sigma & m.sigma
        f = {
            str((q1, q2))
            for (q1, q2) in cross_product_states
            if q1 in self.f and q2 in m.f
        }
        delta: Dict[str, Dict[str, str]] = dict()

        for q1, q2 in cross_product_states:
            actual_state = str((q1, q2))
            delta[actual_state] = {}
            common_sigma = filter(
                lambda x: x in sigma,
                set(self.delta[q1].keys()) | set(m.delta[q2].keys()),
            )
            for a in common_sigma:
                delta[actual_state][a] = str(
                    (self.delta[q1][a], m.delta[q2][a])
                )

        return DFA(q, sigma, delta, initial_state, f)

    def get_nfa(self):
        from nfa import NFA  # fixed import

        """Convert the DFA to an NFA."""
        q = self.q.copy()
        delta = {}
        initial_state = self.initial_state
        f = self.f.copy()
        sigma = self.sigma

        for state, transition in self.delta.items():
            tmp = {}
            for s, _q in transition.items():
                tmp[s] = {_q}
            delta[state] = tmp

        return NFA(q, sigma, delta, initial_state, f)

    # -------------------
    # Minimization
    # -------------------
    def __states_idx_table(self, p_k: Set[FrozenSet[str]]) -> Dict[str, int]:
        states_idx: Dict[str, int] = {}
        for i in range(len(p_k)):
            for state in list(p_k)[i]:
                states_idx[state] = i
        return states_idx

    def __define_group_ith_element(
        self,
        i: int,
        new_p_k: List[Set[str]],
        p_i_sigma: Set[str],
        p_states_lst: List[str],
        states_idx: Dict[str, int],
    ) -> Tuple[List[Set[str]], bool]:
        was_added = False
        for new_p_states in new_p_k:
            new_p_states_lst = list(new_p_states)
            new_p_sigma = set(self.delta[new_p_states_lst[0]].keys())
            if p_i_sigma != new_p_sigma:
                continue
            are_equivalent = all(
                list_map(
                    lambda s,
                    p=p_states_lst[i],
                    q=new_p_states_lst[0],
                    table=states_idx,
                    delta=self.delta: table[delta[p][s]] == table[delta[q][s]],
                    p_i_sigma,
                )
            )
            if are_equivalent:
                new_p_states.add(p_states_lst[i])
                was_added = True
                break
        return new_p_k, was_added

    def minimize(self) -> "DFA":
        """Hopcroft-style DFA minimization."""
        p_k: Set[FrozenSet[str]] = {
            frozenset(self.q - self.f),
            frozenset(self.f),
        }
        p_prev: Set[FrozenSet[str]] = set()

        while p_k != p_prev:
            states_idx = self.__states_idx_table(p_k)
            new_p_k: List[Set[str]] = []
            for p_states in p_k:
                p_states_lst = list(p_states)
                new_p_k.append({p_states_lst[0]})
                for i in range(1, len(p_states_lst)):
                    was_added = False
                    p_i_sigma = set(self.delta[p_states_lst[i]].keys())
                    new_p_k, was_added = self.__define_group_ith_element(
                        i, new_p_k, p_i_sigma, p_states_lst, states_idx
                    )
                    if not was_added:
                        new_p_k.append({p_states_lst[i]})
            p_prev, p_k = p_k, {frozenset(s) for s in new_p_k}

        states_idx = self.__states_idx_table(p_k)
        initial_state = f"q{states_idx[self.initial_state]}"
        final_states = set(list_map(lambda s: f"q{states_idx[s]}", self.f))

        delta: Dict[str, Dict[str, str]] = {}
        states = {f"q{idx}" for idx in states_idx.values()}

        for state_group in p_k:
            fst_state = list(state_group)[0]
            delta[f"q{states_idx[fst_state]}"] = {}
            for s in self.delta[fst_state]:
                delta[f"q{states_idx[fst_state]}"][s] = f"q{states_idx[self.delta[fst_state][s]]}"

        return DFA(states, self.sigma.copy(), delta, initial_state, final_states)

    # -------------------
    # Visualization
    # -------------------
    def view(
        self,
        file_name: str,
        file_format: Literal["svg", "png"] = "png",
        node_attr: Optional[Dict[str, str]] = None,
        edge_attr: Optional[Dict[str, str]] = None,
    ) -> None:
        dot = self._create_base_graph(file_name, file_format, node_attr, edge_attr)
        for q in self.delta:
            for s in self.delta[q]:
                dot.edge(q, self.delta[q][s], label=s)
        dot.render()

    def generate_dfa_visualization(self) -> Digraph:
        dot = Digraph(engine="dot", graph_attr={"rankdir": "LR"})
        for state in self.q:
            shape = "doublecircle" if state in self.f else "circle"
            dot.node(str(state), shape=shape)
        for source, transitions in self.delta.items():
            for symbol, target in transitions.items():
                dot.edge(str(source), str(target), label=str(symbol))
        return dot

    # -------------------
    # Validation + Animation
    # -------------------
    def validate_dfa(self, string: str) -> Tuple[bool, List[Tuple[str, bool]]]:
        state_checks: List[Tuple[str, bool]] = []
        current_state = self.initial_state
        state_checks.append((current_state, True))

        for char in string:
            transitions = self.delta.get(current_state, {})
            next_state = transitions.get(char)
            if next_state is None:
                for symbol, candidate in transitions.items():
                    if "," in symbol and char in {piece.strip() for piece in symbol.split(",")}:
                        next_state = candidate
                        break
            state_checks.append((current_state, next_state is not None))
            if next_state is None:
                return False, state_checks
            current_state = next_state

        accepted = current_state in self.f
        state_checks.append((current_state, accepted))
        return accepted, state_checks

    def animate_dfa_validation(
        self,
        state_checks: List[Tuple[str, bool]],
        delay: float = 1.0,
        blink: float = 0.5,
    ) -> None:
        if st is None:
            raise RuntimeError("Streamlit is required for animation. pip install streamlit")
        dot = self.generate_dfa_visualization()
        placeholder = st.empty()
        placeholder.graphviz_chart(dot.source, use_container_width=True)
        for state, is_valid in state_checks:
            time.sleep(delay)
            fill = "green" if is_valid and state in self.f else "yellow" if is_valid else "red"
            dot.node(str(state), style="filled", fillcolor=fill)
            placeholder.graphviz_chart(dot.source, use_container_width=True)
            if is_valid and state not in self.f:
                time.sleep(blink)
                dot.node(str(state), style="filled", fillcolor="white")
                placeholder.graphviz_chart(dot.source, use_container_width=True)

    # -------------------
    # Final accept (the one you want)
    # -------------------
    def accept(self, string: str, animate: bool = False) -> bool:
        """Check whether the DFA accepts the provided string, with optional animation."""
        accepted, checks = self.validate_dfa(string)
        if animate:
            self.animate_dfa_validation(checks)
        return accepted

